#!/usr/bin/env node

import { spawn } from "node:child_process";
import { readdir, writeFile } from "node:fs/promises";
import type { Dirent } from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import process from "node:process";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const uiRoot = path.resolve(__dirname, "..");
const srcDir = path.join(uiRoot, "src");
const componentsDir = path.join(srcDir, "components", "ui");
const libDir = path.join(srcDir, "lib");
const indexFile = path.join(srcDir, "index.ts");

const allowedExtensions = new Set([".js", ".jsx", ".ts", ".tsx", ".mjs", ".cjs"]);

type ExportPath = string;

type NodeError = NodeJS.ErrnoException;

function isNodeError(error: unknown): error is NodeError {
  return typeof error === "object" && error !== null && "code" in (error as Record<string, unknown>);
}

function stripExtension(filePath: string): string {
  const ext = path.extname(filePath);
  return filePath.slice(0, -ext.length);
}

async function runShadcnAdd(args: string[]): Promise<void> {
  const command = process.platform === "win32" ? "pnpm.cmd" : "pnpm";
  const child = spawn(command, ["dlx", "shadcn@latest", "add", ...args], {
    cwd: uiRoot,
    stdio: "inherit",
  });

  await new Promise<void>((resolve, reject) => {
    child.on("error", reject);
    child.on("close", (code) => {
      if (code === 0) {
        resolve();
      } else {
        reject(new Error(`shadcn add exited with code ${code}`));
      }
    });
  });
}

async function collectExports(dir: string, baseDir: string): Promise<ExportPath[]> {
  const exports = new Set<ExportPath>();
  let entries: Dirent[] = [];

  try {
    entries = await readdir(dir, { withFileTypes: true });
  } catch (error) {
    if (isNodeError(error) && error.code === "ENOENT") {
      return [];
    }
    throw error;
  }

  for (const entry of entries) {
    const absolute = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      const nestedExports = await collectExports(absolute, baseDir);
      nestedExports.forEach((value) => exports.add(value));
      continue;
    }

    if (!entry.isFile()) {
      continue;
    }

    if (entry.name.endsWith(".d.ts")) {
      continue;
    }

    const ext = path.extname(entry.name);

    if (!allowedExtensions.has(ext)) {
      continue;
    }

    const relativePath = path.relative(baseDir, absolute).split(path.sep).join("/");
    const withoutExt = stripExtension(relativePath);

    exports.add(`./${withoutExt}`);
  }

  return Array.from(exports).sort((a, b) => a.localeCompare(b));
}

function buildIndexContent(componentExports: ExportPath[], libExports: ExportPath[]): string {
  const lines: string[] = [
    "// AUTO-GENERATED BY scripts/components-add.ts",
    "// DO NOT EDIT MANUALLY. Run `pnpm run components:add <component>` again to refresh.",
    "",
  ];

  for (const value of componentExports) {
    lines.push(`export * from "${value}";`);
  }

  if (componentExports.length > 0 && libExports.length > 0) {
    lines.push("");
  }

  for (const value of libExports) {
    lines.push(`export * from "${value}";`);
  }

  lines.push("", "");
  return lines.join("\n");
}

async function updateIndexExports(): Promise<void> {
  const [componentExports, libExports] = await Promise.all([
    collectExports(componentsDir, srcDir),
    collectExports(libDir, srcDir),
  ]);

  const content = buildIndexContent(componentExports, libExports);
  await writeFile(indexFile, content, "utf8");
}

async function main(): Promise<void> {
  const args = process.argv.slice(2);

  if (args.includes("--refresh")) {
    await updateIndexExports();
    return;
  }

  await runShadcnAdd(args);
  await updateIndexExports();
}

main().catch((error) => {
  console.error(error);
  process.exit(1);
});
